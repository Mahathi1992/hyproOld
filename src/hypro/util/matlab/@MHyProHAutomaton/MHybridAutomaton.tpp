#include "MHybridAutomaton.h"

    /**
     * @brief
     **/
    void MHybridAutomaton::new_empty(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::copy(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::new_loc(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::del_automaton(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getLocations(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getLocation_by_hash(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getLocation_by_name(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getTransitions(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getInitialStates(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getLocalBadStates(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getGlobalBadStates(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::dimension(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getVariables(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getLabels(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::setLocations(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::setTransitions(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::setInitialStates(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::setLocalBadStates(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::setGlobalBadStates(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::setVariables(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::addLocation(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

      /**
       * @brief
       **/  
    //void MHybridAutomaton::addLocation_ptr(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    //}

    /**
     * @brief
     **/    
    void MHybridAutomaton::addTransition(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

       /**
        * @brief
        **/ 
    // void MHybridAutomaton::addTransition_ptr(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    //}

    /**
     * @brief
     **/    
    void MHybridAutomaton::addInitialState(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::addLocalBadState(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::addGlobalBadState(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::removeTransition(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::decompose(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::reduce(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::isComposedOf(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getDotRepresentation(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::getStatistics(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::equals(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::unequals(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::or_operator(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::plus(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::outstream(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }

    /**
     * @brief
     **/    
    void MHybridAutomaton::checkConsistnecy(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){

    }


    /**
     * @brief
     **/
    void MHybridAutomaton::process(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]){
    //     // Get the command string
    // char cmd[64];
    // if (nrhs < 1 || mxGetString(prhs[1], cmd, sizeof(cmd)))
    //     mexErrMsgTxt("HyProBox - First input should be a command string less than 64 characters long.");
    
    // /***************************************************************************
    //  * Constructors
    //  **************************************************************************/

    // if (!strcmp("new_empty", cmd) && nrhs == 2){  
    //     emptyBox(nlhs, plhs, prhs);
    //     return;
    // }
    
    // // Check if there is a second input, which should be the class instance handle
    // if (nrhs < 2){
    //     mexErrMsgTxt("Second input should be a Box instance handle.");
    // }
    
    // if(!strcmp("copy", cmd)){
    //     copyObj(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("new_interval", cmd)){
    //     boxFromSingleInterval(nlhs, plhs, prhs);
    //     return;
    // }

    // if(!strcmp("new_intervals", cmd)){
    //     boxFromIntervals(nlhs, plhs, prhs);
    //     return;
    // }

    // if(!strcmp("new_points",cmd)){
    //     boxFromPoints(nlhs, plhs, prhs);
    //     return;
    // }

    // if(!strcmp("new_matrix",cmd)){
    //     //boxFromMatrix(nlhs, plhs, nrhs, prhs);
    //     new_mat_vec(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if (!strcmp("delete", cmd)) {
    //     // deleteBox(nlhs, nrhs, prhs);
    //     deleteObject(nlhs, plhs, nrhs, prhs);
    //     return;
    // }
    
    // /***************************************************************************
    //  * Getters & setters
    //  **************************************************************************/ 

    // if(!strcmp("getSettings", cmd)){
    //     getSettings(nlhs, plhs,  prhs);
    //     return;
    // }

    // if(!strcmp("empty", cmd)){
    //     empty(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("intervals", cmd)){
    //     intervals(nlhs, plhs, prhs);
    //     return;
    // }

    // if(!strcmp("insert", cmd)){
    //     insert(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("limits", cmd)){
    //     limits(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("matrix", cmd)){
    //     matrix(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("vector", cmd)){
    //     vector(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("constraints", cmd)){
    //     constraints(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("interval", cmd)){
    //     interval(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("at", cmd)){
    //     at(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("isEmpty", cmd)){
    //     is_empty(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("isSymmetric", cmd)){
    //     is_symmetric(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("max", cmd)){
    //     max(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("min", cmd)){
    //     min(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("supremum", cmd)){
    //     supremum(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("vertices", cmd)){
    //     vertices(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("evaluate", cmd)){
    //     evaluate(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("multiEvaluate", cmd)){
    //     multiEvaluate(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("==", cmd)){
    //     equal(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("!=", cmd)){
    //     unequal(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("*", cmd)){
    //     scale(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("<<", cmd)){
    //     outstream(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // /**************************************************************************
    //  * General interface
    // **************************************************************************/
    
    // if(!strcmp("dimension", cmd)){
    //     dimension(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("removeRedundancy", cmd)){
    //     removeRedundancy(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("size", cmd)){
    //     box_size(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("type", cmd)){
    //     type(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("reduceNumberRepresentation", cmd)){
    //     reduceNumberRepresentation(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("makeSymmetric", cmd)){
    //     makeSymmetric(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("satisfiesHalfspace", cmd)){
    //     satisfiesHalfspace(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("satisfiesHalfspaces", cmd)){
    //     satisfiesHalfspaces(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("project", cmd)){
    //     project(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("linearTransformation", cmd)){
    //     linearTransformation(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("affineTransformation", cmd)){
    //     affineTransformation(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("minkowskiSum", cmd)){
    //     minkowskiSum(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("minkowskiDecomposition", cmd)){
    //     minkowskiDecomposition(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("intersect", cmd)){
    //     intersect(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("intersectHalfspace", cmd)){
    //     intersectHalfspace(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("intersectHalfspaces", cmd)){
    //     reduceNumberRepresentation(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("contains_point", cmd)){
    //     contains_point(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("contains_set", cmd)){
    //     contains_object(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("unite", cmd)){
    //     unite_single(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("unite_objects", cmd)){
    //     unite_vec(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("reduceRepresentation", cmd)){
    //     reduceRepresentation(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    // if(!strcmp("clear", cmd)){
    //     clear(nlhs, plhs, nrhs, prhs);
    //     return;
    // }

    mexErrMsgTxt("Hy- Command not recognized.");
}
